
### zset(sort list) 的数据结构是什么？

zset 有序且唯一，在跳表以空间换时间 以冗余的链表换取效率

![](https://coding3min.oss-accelerate.aliyuncs.com/2021/03/08/Xw0RLM1111.jpg)

### 为什么要用跳表不用B+树的结构呢？

答者：Shawn

B+树的每个节点可以存储多个关键字，而Redis是 内存中读取数据，不涉及IO，因此使用了跳表

### lru和ttl，大量过期时会不会阻塞

不会，因为redis是闲时清理，可以设置最高占用cpu，清理是基于概率的，存在部分key总是无法清理的情况在，另外清理key的过程是不会fork子进程

### 什么时候会fork子进程

rdb 、aof、主从无盘复制方式传输

### key清理不干净会不会遇到什么业务上的问题，万一用到了会发生什么？通过什么办法解决？

如果是lru的话，假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，会更新ttl，不会被淘汰。

优化的话就增大maxmemory-sample，增加每次lru数据的个数，淘汰起来更精确

在redis>4.0版本，有LFU算法，访问不频繁的优先淘汰就好了

另外redis有三种删除策略

惰性删除，也就是在置换的时候删除

定时删除，固定时间段执行删除操作

定期删除，和定时删除一样，区别会时间期是根据业务来自动取的

另外rdb和aof的持久化策略中，rdb读取时不会读取过期数据，aof有rewrite功能，执行行也不会存过期的策略

太频繁的主动删除对cpu不友好，惰性删除对内存不友好，一旦插入大key，会出现cpu使用高峰

### bigkey还会出现什么问题？

网络阻塞、redis超时、分片内存不均匀导致某些节点占用内存多

避免bigkey的方法，主要是对 bigkey 进行拆分，拆成多个 key，然后用MGET取回来，再在业务层做合并。

### 集群模式没有mget命令怎么办？

再加个map存在key列表，然后并行取

### 众所周知 redis 是单线程的（主要读写 io 操作 寻址等），为什么不设计成多线程的？

Redis的核心是快『基于内存』，主要有以下观点：由『避免了上下文切换和cpu的竞争，更加无需考虑各种锁操作，也不会和mysql一样存在死锁导致的问题』。

因为数据是存储在内存中，内存中的运行非常快，但是如果存在上面的锁，和上下文切换，可能就不会那么快了。

有利于开发人员规范代码，单线程的代码比多核异步更加清晰明了。

### 单线程虽然有这些好处，但一定会浪费一些多核cpu的性能优势，如果是你设计会怎么考虑？

还得看cpu的频率，如果cpu的频率低，并且访问redis的并发很大，那么单个redis线程分摊到每个cpu上的压力也是非常可观的。（一个线程并不是一直都bind到一个固定的核上面的， 其实这也是常遇到的错误的认知：单个线程就算用多核的机器也是浪费的观念）

虽然redis是单线程，如果有需要可以使用多实例来模拟出多线程或者多进程

### 最后

如果文中有误，欢迎提pr或者issue，**一旦合并或采纳作为贡献奖励可以联系我直接无门槛**加入[技术交流群](https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q)

我是小熊，关注我，知道更多不知道的技术

![](https://coding3min.oss-accelerate.aliyuncs.com/2021/03/11/gQDiQ51116.jpg)
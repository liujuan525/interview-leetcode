1	
20	
21	
53	
70	
101	
104	
121	
136	
141	
155	
160	
169	
206	
226	
234	
283	
448	
461	
543	
617	

总计26题，题目列表请戳 [LeetCode Hot100 easy 列表](https://leetcode-cn.com/problemset/leetcode-hot-100/?difficulty=%E7%AE%80%E5%8D%95)。

全部源码可见我的GitHub (LeetCode)(https://github.com/minibear2333/LeetCode)

注：

有下划线标志的都是超链接。
点击下列题目标题可以跳转到LeetCode中文官网直接阅读题目，提交代码。
点击下列代码链接，可以直接跳转到我的GitHub代码页面。每道题一般精选一种解法，我的GitHub中可能收录多种解法代码，请自行查看。


1. 两数之和：用数组位置查找数组值，O(1)；用数组值查找数组位置想要达到O(1)，用HashMap--常用技巧。【我的代码】。

2.  有效的括号： 【栈】。

3.  合并两个有序链表：可以【循环】，也可以采用【递归】。

4.  最大子序和： 一次循环，maxEndingHere储存以该点结尾的子序和，maxSoFar储存到该点的最大子序和。【我的代码】。

5.  爬楼梯： 循环，一次只储存两个值。【我的代码】。

6.   对称二叉树：日常递归。【我的代码】。

7.   二叉树的最大深度： 【一行递归】。
8.   买卖股票的最佳时机：与目前最小值做差，求差的最大值，一次循环就够了。【我的代码】。
9.   只出现一次的数字：【异或的性质】, a^a=0, a^0=a。
10.  环形链表: 快慢指针。
11.  最小栈: 需要辅助栈。【同步栈】，【不同步栈】。
12.  相交链表: 所有寻找同一节点链表题的本质（如相交，环），都是对加法交换律的花式运用。【我的代码】。尤其注意代码中如果写成

        while(A!=B){
            A=A.next==null? headB:A.next;
            B=B.next==null? headA:B.next;
        }
这个循环就永远出不去了。。。
1.   多数元素：我将这种算法称为 【抱对自杀】，每当一个众数碰到一个非众数就会抱住，然后双双自杀。如果没有遇到足够的非众数，众数们就会等人到齐了再抱对自杀。最后留下来的当然是众数。
2.   打家劫舍：看到这一道题第一反应是递归，但是简单递归会导致大量重复计算量，因此应该标记计算过的节点，【我的代码】。但实际上，我们真的需要储存那么多中间值嘛？并不是，只用存前一个值和前前一个值就好，所以其实可以用【简单循环】解决这个问题--跟 70. 爬楼梯 是类似的。
3.   反转链表：【我的代码】。其实是234. 回文链表 的一部分。
4.   翻转二叉树：自身递归，“交换”左右子树时记得备份。【我的代码】。
5.   回文链表: 快慢指针（整除器），把剩下的一半变成逆序，再进行比较。注意奇偶情况讨论。【我的代码】。
6.   移动零：将非零元素依次交换到前面来。【我的代码】。
7.   路径总和 III ：经典划分：树 = 根节点+左子树+右子树。好的划分是递归的基础。【我的代码】。
8.   找到字符串中所有字母异位词：【滑动窗口】。
9.   找到所有数组中消失的数字：把数字放到对应位置上去，最后依次找出没有正确摆放数字的位置。千万注意，调换的时候，数组的角标含义可能会发生变化。【我的代码】。
10.  汉明距离：十进制向二进制转换技巧：整除/2，或右移>>1；异或^的用法。【我的代码】。
11.  把二叉搜索树转换为累加树：树的经典题，dfs，右孩子-根-左孩子。【我的代码】。
12.  二叉树的直径：dfs求节点到叶子节点的距离，叶子节点的到叶子节点距离定义为1。dfs遍历所有节点找出最大直径。【我的代码】。
13.  最短无序连续子数组：四遍循环。从左至右找无序子数组极小值，从右至左找无序子数组极大值，从左至右找无序子数组左边起始点，从右至左找无序子数组右边起始点。 【我的代码】。
14.  合并二叉树：递归，经典划分：树=根+左子树+右子树，跟437 路径总和 III的思想是一样的。【我的代码】。